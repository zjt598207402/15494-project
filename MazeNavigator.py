from cozmo_fsm import *
from Movement import DecideMove, ForwardCustom, TurnCustom, Build_walls
from Calibrator import mergeLines, getWalls, getDistanceForward
from tkinter import *


class initMaze(StateNode):
    def start(self, event = None):
        if self.running: return
        self.parent.walls = {(0,0):[1,0,1,1]}
        self.parent.visited = {}
        self.parent.cozmo_x = 0
        self.parent.cozmo_y =0
        self.parent.cozmo_head = 1
        self.parent.canvas_height = 500
        self.parent.canvas_width = 500
        self.parent.root = Tk()
        self.parent.canvas = Canvas(self.parent.root, width=self.parent.canvas_width \
            , height=self.parent.canvas_height)
        self.parent.canvas.pack()
        super().start(event)
        self.post_completion()

class ObjectSeen(StateNode):
    def start(self, event = None):
        if self.running: return
        super().start(event)
        print("Checking Object")
        if cube1.is_visible:
            print("POSTING SUCESS")
            self.post_success()
        else:
            print("POSTING FAILURE")
            self.post_failure()

class MazeNavigator(StateMachineProgram):
    def start(self):
        super().start()
        cv2.namedWindow('features')
        dummy = numpy.array([[0]*320])
        cv2.imshow('features',dummy)
        cv2.createTrackbar('minDistance','features',0,1000,lambda self: None)
        cv2.createTrackbar('threshContour','features',170,1000,lambda self: None)
        cv2.createTrackbar('threshold1','features',1000,1000,lambda self: None)
        cv2.createTrackbar('threshold2','features',1000,1000,lambda self: None)
        cv2.createTrackbar('votes','features',13,1000,lambda self: None)
        self.count = 0
        default_head_angle = -0.67

        if (not math.isclose(self.robot._head_angle.degrees, default_head_angle, abs_tol=1)):
            self.robot.set_head_angle(degrees(default_head_angle))

        # super().start()

    def user_image(self,image,gray):
        threshContour = cv2.getTrackbarPos('threshContour', 'features')
        threshold1 = cv2.getTrackbarPos('threshold1', 'features')
        threshold2 = cv2.getTrackbarPos('threshold2', 'features')

        ret, thresholded = cv2.threshold(gray, threshContour, 255, 0)
        self.edges = cv2.Canny(thresholded, \
            threshold1, threshold2, apertureSize = 3)
        votes = cv2.getTrackbarPos('votes', 'features')
        self.lines = cv2.HoughLinesP(self.edges,1,np.pi/180,votes)


    def user_annotate(self,image):
        if self.edges is None: return image
        lines = self.lines
        MAX_LINES = 100

        if (lines is not None):
            if len(lines) < MAX_LINES:
                lines = mergeLines(lines, self.count)

                walls = getWalls(lines)
                self.distanceForward = getDistanceForward(lines)
                self.curWall = walls
                print(walls)

                for line in lines:
                    cv2.line(image, (line[0], line[1]), (line[2], line[3]), (0, 0, 255), 2)
        self.count = 1
        return image

    def setup(self):
        """
            initMaze() =C=> StateNode() =T(5)=>
            checkObject: ObjectSeen() 
            checkObject =F=> StateNode() =T(2)=> Build_walls() =C=> 
                decideMove: DecideMove()
                decideMove =S=> ForwardCustom() =C=> checkObject
                decideMove =F=> TurnCustom() =C=> StateNode() =T(2)=> checkObject 
            checkObject =S=> PickUpObject(cube1)
    
        """
        
        # Code generated by genfsm on Sun May  7 23:44:33 2017:
        
        initmaze1 = initMaze() .set_name("initmaze1") .set_parent(self)
        statenode1 = StateNode() .set_name("statenode1") .set_parent(self)
        checkObject = ObjectSeen() .set_name("checkObject") .set_parent(self)
        statenode2 = StateNode() .set_name("statenode2") .set_parent(self)
        build_walls1 = Build_walls() .set_name("build_walls1") .set_parent(self)
        decideMove = DecideMove() .set_name("decideMove") .set_parent(self)
        forwardcustom1 = ForwardCustom() .set_name("forwardcustom1") .set_parent(self)
        turncustom1 = TurnCustom() .set_name("turncustom1") .set_parent(self)
        statenode3 = StateNode() .set_name("statenode3") .set_parent(self)
        pickupobject1 = PickUpObject(cube1) .set_name("pickupobject1") .set_parent(self)
        
        completiontrans1 = CompletionTrans() .set_name("completiontrans1")
        completiontrans1 .add_sources(initmaze1) .add_destinations(statenode1)
        
        timertrans1 = TimerTrans(5) .set_name("timertrans1")
        timertrans1 .add_sources(statenode1) .add_destinations(checkObject)
        
        failuretrans1 = FailureTrans() .set_name("failuretrans1")
        failuretrans1 .add_sources(checkObject) .add_destinations(statenode2)
        
        timertrans2 = TimerTrans(2) .set_name("timertrans2")
        timertrans2 .add_sources(statenode2) .add_destinations(build_walls1)
        
        completiontrans2 = CompletionTrans() .set_name("completiontrans2")
        completiontrans2 .add_sources(build_walls1) .add_destinations(decideMove)
        
        successtrans1 = SuccessTrans() .set_name("successtrans1")
        successtrans1 .add_sources(decideMove) .add_destinations(forwardcustom1)
        
        completiontrans3 = CompletionTrans() .set_name("completiontrans3")
        completiontrans3 .add_sources(forwardcustom1) .add_destinations(checkObject)
        
        failuretrans2 = FailureTrans() .set_name("failuretrans2")
        failuretrans2 .add_sources(decideMove) .add_destinations(turncustom1)
        
        completiontrans4 = CompletionTrans() .set_name("completiontrans4")
        completiontrans4 .add_sources(turncustom1) .add_destinations(statenode3)
        
        timertrans3 = TimerTrans(2) .set_name("timertrans3")
        timertrans3 .add_sources(statenode3) .add_destinations(checkObject)
        
        successtrans2 = SuccessTrans() .set_name("successtrans2")
        successtrans2 .add_sources(checkObject) .add_destinations(pickupobject1)
        
        return self
